<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pente de Garage - Calculateur</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: #f5f5f5;
        color: #333;
        padding: 20px;
        line-height: 1.6;
      }

      #app {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 20px;
        color: #2c3e50;
      }

      h2 {
        font-size: 1.5rem;
        margin: 20px 0 10px;
        color: #34495e;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .section {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .input-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #555;
      }

      input[type="number"],
      select {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
        transition: border-color 0.2s;
      }

      input[type="number"]:focus,
      select:focus {
        outline: none;
        border-color: #3498db;
      }

      .canvas-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 20px;
      }

      canvas {
        display: block;
        width: 100%;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      .result {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .result h2 {
        margin-top: 0;
      }

      .status {
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 10px;
        font-weight: 500;
      }

      .status.success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status.error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .details {
        font-size: 0.9rem;
        color: #666;
        margin-top: 10px;
      }

      .specs {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 4px;
        margin-top: 15px;
        border-left: 4px solid #3498db;
      }

      .specs h3 {
        font-size: 1.1rem;
        margin-bottom: 10px;
        color: #2c3e50;
      }

      .specs p {
        margin: 5px 0;
      }

      .section-spec {
        background-color: white;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        border: 1px solid #ddd;
      }

      .warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeeba;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
      }

      @media (max-width: 768px) {
        .container {
          grid-template-columns: 1fr;
        }
        
        h1 {
          font-size: 1.5rem;
        }
        
        h2 {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script>
      // LocalStorage keys
      const STORAGE_KEY = 'pente-garage-data';

      // Default values
      const defaultData = {
        path: {
          distance: 530,      // Distance directe A-B en cm
          elevation: -75,     // D√©nivel√© en cm (n√©gatif = descente)
          slopeCount: 3       // Nombre de sections de pente (1, 2, ou 3)
        },
        vehicle: {
          length: 420,
          wheelbase: 268.5,
          groundClearance: 13.5
        }
      };

      // Load data from localStorage or use defaults
      function loadData() {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? JSON.parse(saved) : defaultData;
      }

      // Save data to localStorage
      function saveData(data) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      }

      // Initialize app
      let appData = loadData();

      // Create HTML structure
      document.querySelector('#app').innerHTML = `
        <h1>Calculateur de Pente d'All√©e de Garage</h1>
        
        <div class="container">
          <div class="section">
            <h2>Param√®tres du Trajet (Point A ‚Üí Point B)</h2>
            <div class="input-group">
              <label for="pathDistance">Distance directe A-B (cm)</label>
              <input type="number" id="pathDistance" value="${appData.path.distance}" min="100" step="10">
            </div>
            <div class="input-group">
              <label for="pathElevation">D√©nivel√© (cm, n√©gatif = descente)</label>
              <input type="number" id="pathElevation" value="${appData.path.elevation}" step="1">
            </div>
            <div class="input-group">
              <label for="slopeCount">Nombre de sections de pente</label>
              <select id="slopeCount">
                <option value="1" ${appData.path.slopeCount === 1 ? 'selected' : ''}>1 pente unique</option>
                <option value="2" ${appData.path.slopeCount === 2 ? 'selected' : ''}>2 pentes</option>
                <option value="3" ${appData.path.slopeCount === 3 ? 'selected' : ''}>3 pentes</option>
              </select>
            </div>
          </div>
          
          <div class="section">
            <h2>Caract√©ristiques du V√©hicule</h2>
            <div class="input-group">
              <label for="vehicleLength">Longueur totale (cm)</label>
              <input type="number" id="vehicleLength" value="${appData.vehicle.length}" min="100" step="0.5">
            </div>
            <div class="input-group">
              <label for="wheelbase">Empattement (cm)</label>
              <input type="number" id="wheelbase" value="${appData.vehicle.wheelbase}" min="100" step="0.5">
            </div>
            <div class="input-group">
              <label for="groundClearance">Garde au sol (cm)</label>
              <input type="number" id="groundClearance" value="${appData.vehicle.groundClearance}" min="1" step="0.5">
            </div>
          </div>
        </div>
        
        <div class="canvas-container">
          <h2>Visualisation de l'All√©e</h2>
          <canvas id="garageCanvas" width="800" height="400"></canvas>
        </div>
        
        <div class="result">
          <h2>Pentes Calcul√©es et Sp√©cifications</h2>
          <div id="calculationResult"></div>
        </div>
      `;

      // Get input elements
      const inputs = {
        pathDistance: document.getElementById('pathDistance'),
        pathElevation: document.getElementById('pathElevation'),
        slopeCount: document.getElementById('slopeCount'),
        vehicleLength: document.getElementById('vehicleLength'),
        wheelbase: document.getElementById('wheelbase'),
        groundClearance: document.getElementById('groundClearance')
      };

      // Add event listeners
      Object.keys(inputs).forEach(key => {
        inputs[key].addEventListener('input', handleInputChange);
        inputs[key].addEventListener('change', handleInputChange);
      });

      function handleInputChange() {
        // Update appData
        appData.path.distance = parseFloat(inputs.pathDistance.value);
        appData.path.elevation = parseFloat(inputs.pathElevation.value);
        appData.path.slopeCount = parseInt(inputs.slopeCount.value);
        appData.vehicle.length = parseFloat(inputs.vehicleLength.value);
        appData.vehicle.wheelbase = parseFloat(inputs.wheelbase.value);
        appData.vehicle.groundClearance = parseFloat(inputs.groundClearance.value);
        
        // Save to localStorage
        saveData(appData);
        
        // Calculate optimal slopes
        const slopes = calculateOptimalSlopes();
        
        // Update visualization and display results
        drawPath(slopes);
        displayResults(slopes);
      }

      // Calculate optimal slopes based on distance, elevation and vehicle constraints
      function calculateOptimalSlopes() {
        const distance = appData.path.distance;
        const elevation = Math.abs(appData.path.elevation); // Work with positive value
        const slopeCount = appData.path.slopeCount;
        
        // Calculate section lengths (equal distribution)
        const sectionLength = distance / slopeCount;
        
        // Calculate elevation per section (equal distribution)
        const elevationPerSection = elevation / slopeCount;
        
        // Create slope sections
        const slopes = [];
        for (let i = 0; i < slopeCount; i++) {
          slopes.push({
            length: sectionLength,
            drop: elevationPerSection,
            angle: Math.atan(elevationPerSection / sectionLength) * (180 / Math.PI),
            percentage: (elevationPerSection / sectionLength) * 100
          });
        }
        
        // Check vehicle clearance
        const clearanceCheck = checkVehicleClearance(slopes);
        
        return {
          sections: slopes,
          totalLength: distance,
          totalDrop: elevation,
          vehicleCheck: clearanceCheck
        };
      }

      // Check if vehicle can pass without touching ground
      function checkVehicleClearance(slopesSections) {
        const frontOverhang = (appData.vehicle.length - appData.vehicle.wheelbase) / 2;
        
        // Build height profile
        function getHeightAtPosition(x) {
          let cumulativeLength = 0;
          let cumulativeDrop = 0;
          
          for (let section of slopesSections) {
            if (x <= cumulativeLength + section.length) {
              const progressInSection = x - cumulativeLength;
              const dropInSection = (progressInSection / section.length) * section.drop;
              return -(cumulativeDrop + dropInSection);
            }
            cumulativeLength += section.length;
            cumulativeDrop += section.drop;
          }
          return -cumulativeDrop;
        }
        
        let minClearance = Infinity;
        let criticalPosition = null;
        let touches = false;
        
        // Simulate vehicle movement
        const step = 5;
        const totalLength = slopesSections.reduce((sum, s) => sum + s.length, 0);
        
        for (let vehiclePos = -appData.vehicle.length; vehiclePos <= totalLength; vehiclePos += step) {
          const frontWheelX = vehiclePos + frontOverhang;
          const rearWheelX = vehiclePos + frontOverhang + appData.vehicle.wheelbase;
          
          if (frontWheelX >= 0 && frontWheelX <= totalLength &&
              rearWheelX >= 0 && rearWheelX <= totalLength) {
            
            const frontHeight = getHeightAtPosition(frontWheelX);
            const rearHeight = getHeightAtPosition(rearWheelX);
            const vehicleSlope = (rearHeight - frontHeight) / appData.vehicle.wheelbase;
            
            // Check critical points
            const checkPoints = [
              { pos: vehiclePos, name: 'avant' },
              { pos: vehiclePos + appData.vehicle.length / 2, name: 'centre' },
              { pos: vehiclePos + appData.vehicle.length, name: 'arri√®re' }
            ];
            
            for (const point of checkPoints) {
              if (point.pos >= 0 && point.pos <= totalLength) {
                const groundHeight = getHeightAtPosition(point.pos);
                const distFromFrontWheel = point.pos - frontWheelX;
                const wheelHeightAtPoint = frontHeight + vehicleSlope * distFromFrontWheel;
                const vehicleBottomHeight = wheelHeightAtPoint + appData.vehicle.groundClearance;
                const clearance = vehicleBottomHeight - groundHeight;
                
                if (clearance < minClearance) {
                  minClearance = clearance;
                  criticalPosition = { position: vehiclePos.toFixed(0), point: point.name };
                }
                
                if (clearance < 0) {
                  touches = true;
                }
              }
            }
          }
        }
        
        return {
          touches,
          minClearance,
          criticalPosition
        };
      }

      // Draw path visualization
      function drawPath(slopeData) {
        const canvas = document.getElementById('garageCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        const totalLength = slopeData.totalLength;
        const totalDrop = slopeData.totalDrop;
        
        // Calculate scale
        const padding = 50;
        const scale = (width - 2 * padding) / totalLength;
        const heightScale = (height - 2 * padding) / (totalDrop + 50);
        
        // Helper functions
        function toCanvasX(x) {
          return padding + x * scale;
        }
        
        function toCanvasY(y) {
          return height - padding - y * heightScale;
        }
        
        // Draw ground level (point A)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(toCanvasX(0), toCanvasY(0));
        ctx.lineTo(toCanvasX(totalLength), toCanvasY(0));
        ctx.stroke();
        
        // Draw slope profile
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(toCanvasX(0), toCanvasY(0));
        
        let cumulativeLength = 0;
        let cumulativeDrop = 0;
        
        for (let section of slopeData.sections) {
          cumulativeLength += section.length;
          cumulativeDrop += section.drop;
          ctx.lineTo(toCanvasX(cumulativeLength), toCanvasY(-cumulativeDrop));
        }
        
        ctx.stroke();
        
        // Fill area under slope
        ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
        ctx.beginPath();
        ctx.moveTo(toCanvasX(0), toCanvasY(0));
        
        cumulativeLength = 0;
        cumulativeDrop = 0;
        for (let section of slopeData.sections) {
          cumulativeLength += section.length;
          cumulativeDrop += section.drop;
          ctx.lineTo(toCanvasX(cumulativeLength), toCanvasY(-cumulativeDrop));
        }
        
        ctx.lineTo(toCanvasX(totalLength), toCanvasY(0));
        ctx.closePath();
        ctx.fill();
        
        // Draw section markers
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        cumulativeLength = 0;
        cumulativeDrop = 0;
        for (let i = 0; i < slopeData.sections.length - 1; i++) {
          cumulativeLength += slopeData.sections[i].length;
          cumulativeDrop += slopeData.sections[i].drop;
          
          ctx.beginPath();
          ctx.moveTo(toCanvasX(cumulativeLength), toCanvasY(0));
          ctx.lineTo(toCanvasX(cumulativeLength), toCanvasY(-cumulativeDrop));
          ctx.stroke();
        }
        
        ctx.setLineDash([]);
        
        // Draw vehicle
        const vehicleY = 20;
        const vehicleColor = '#e74c3c';
        const frontOverhang = (appData.vehicle.length - appData.vehicle.wheelbase) / 2;
        
        ctx.strokeStyle = vehicleColor;
        ctx.fillStyle = vehicleColor;
        ctx.lineWidth = 2;
        
        // Vehicle body
        ctx.fillRect(
          toCanvasX(50),
          toCanvasY(vehicleY + appData.vehicle.groundClearance + 30),
          appData.vehicle.length * scale,
          30
        );
        
        // Wheels
        const wheelRadius = 15;
        ctx.beginPath();
        ctx.arc(toCanvasX(50 + frontOverhang), toCanvasY(vehicleY + appData.vehicle.groundClearance), wheelRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(toCanvasX(50 + frontOverhang + appData.vehicle.wheelbase), toCanvasY(vehicleY + appData.vehicle.groundClearance), wheelRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Labels
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.fillText('Point A (d√©part)', toCanvasX(0) - 20, toCanvasY(-10));
        ctx.fillText('Point B (arriv√©e)', toCanvasX(totalLength) - 50, toCanvasY(-totalDrop - 10));
      }

      // Display calculation results and construction specifications
      function displayResults(slopeData) {
        const resultDiv = document.getElementById('calculationResult');
        const check = slopeData.vehicleCheck;
        
        let statusHtml = '';
        if (check.touches) {
          statusHtml = `
            <div class="status error">
              ‚ö†Ô∏è Attention: Le v√©hicule risque de toucher le sol
            </div>
            <div class="warning">
              <strong>‚ö†Ô∏è Marge minimale:</strong> ${check.minClearance.toFixed(2)} cm (n√©gatif = contact)<br>
              <strong>Position critique:</strong> ${check.criticalPosition.point} du v√©hicule √† ${check.criticalPosition.position} cm du point A<br>
              <strong>Recommandation:</strong> R√©duisez les pentes ou choisissez un v√©hicule avec plus de garde au sol.
            </div>
          `;
        } else {
          statusHtml = `
            <div class="status success">
              ‚úì Le v√©hicule peut passer sans probl√®me
            </div>
            <div class="details">
              <p><strong>Marge minimale:</strong> ${check.minClearance.toFixed(2)} cm</p>
              <p><strong>Position critique:</strong> ${check.criticalPosition.point} du v√©hicule √† ${check.criticalPosition.position} cm du point A</p>
            </div>
          `;
        }
        
        // Construction specifications
        let specsHtml = '<div class="specs"><h3>üìê Sp√©cifications pour le Ma√ßon</h3>';
        
        specsHtml += `<p><strong>Distance totale A-B:</strong> ${slopeData.totalLength.toFixed(1)} cm (${(slopeData.totalLength / 100).toFixed(2)} m)</p>`;
        specsHtml += `<p><strong>D√©nivel√© total:</strong> ${slopeData.totalDrop.toFixed(1)} cm (${(slopeData.totalDrop / 100).toFixed(2)} m)</p>`;
        specsHtml += `<p><strong>Nombre de sections:</strong> ${slopeData.sections.length}</p>`;
        
        slopeData.sections.forEach((section, index) => {
          specsHtml += `
            <div class="section-spec">
              <strong>Section ${index + 1}:</strong><br>
              ‚Ä¢ Longueur: ${section.length.toFixed(1)} cm (${(section.length / 100).toFixed(2)} m)<br>
              ‚Ä¢ Descente: ${section.drop.toFixed(1)} cm (${(section.drop / 100).toFixed(2)} m)<br>
              ‚Ä¢ Angle: ${section.angle.toFixed(2)}¬∞<br>
              ‚Ä¢ Pente: ${section.percentage.toFixed(2)}%<br>
              ${index === 0 ? '‚Ä¢ Point de d√©part: niveau du point A (0 cm)' : ''}
              ${index === slopeData.sections.length - 1 ? `‚Ä¢ Point d'arriv√©e: ${slopeData.totalDrop.toFixed(1)} cm sous le point A` : ''}
            </div>
          `;
        });
        
        specsHtml += '<h3 style="margin-top: 15px;">üìã Instructions de Construction</h3>';
        specsHtml += '<p>1. Marquez le point A (d√©part) au niveau de r√©f√©rence (0 cm)</p>';
        
        let cumulativeLength = 0;
        let cumulativeDrop = 0;
        
        slopeData.sections.forEach((section, index) => {
          cumulativeLength += section.length;
          cumulativeDrop += section.drop;
          
          specsHtml += `<p>${index + 2}. √Ä ${cumulativeLength.toFixed(1)} cm (${(cumulativeLength / 100).toFixed(2)} m) du point A, `;
          specsHtml += `la hauteur doit √™tre de ${cumulativeDrop.toFixed(1)} cm (${(cumulativeDrop / 100).toFixed(2)} m) en dessous du point A`;
          if (index === slopeData.sections.length - 1) {
            specsHtml += ' <strong>(Point B - arriv√©e)</strong>';
          }
          specsHtml += '</p>';
        });
        
        specsHtml += '</div>';
        
        resultDiv.innerHTML = statusHtml + specsHtml;
      }

      // Initial render
      const initialSlopes = calculateOptimalSlopes();
      drawPath(initialSlopes);
      displayResults(initialSlopes);
    </script>
  </body>
</html>
